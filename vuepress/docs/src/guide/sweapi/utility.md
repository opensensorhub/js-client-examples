# Utility class

The first layer of implementation of the SensorWeb REST API is a utility class to browse server resources and fetch historical data.
The constructor is used to provide server endpoint (API root) and authentication params. The additional methods defined below are helpers for CRUD operations on all resource types available through the API.

The utility class allows access to the API server resources without the need to create DataSources.
They are grouped into several Objects: DataStream, System, Observation, FeatureOfInterest.

## Filters

The filters allow to define the search properties of each route. For example, format, keyword search, time range etc.
Each route has its own properties. For simplicity, only one filter is used per resource type. For example, for System,
we will use a SystemFilter. The user must therefore take care to specify the correct parameters according to the route used.

<br/>
<DocumentationLoad path="/guide/api/SystemFilter.html"/>

### Example

```js
const systemFilter = new SystemFilter({
    q: 'GPS',
    format: 'application/json',
    validTime: '1970-01-01T00:00:00Z/2055-01-01T00:00:00Z'
});
const systemCollection = await systemsUtility.searchSystems(systemFilter, 10);
```

## Collection
Some of these APIs return resource collections. Collection is a JS object containing an array of items and methods for paging (next/previous).

A collection returns a Page, a page is an array of Resources.

<br/>
<DocumentationLoad path="/guide/api/Collection.html"/>

#### Example

```js
const systemCollection = await systemsUtility.searchSystems(systemFilter, 10);

while (systemCollection.hasNext()) {
    const page = await systemCollection.nextPage();
    // do something
}
```

## Properties

Some properties must be set when retrieving certain resources. For example, the method searchDataStreams() will return
a set of DataStream objects allowing then to stream the data.
The default protocol is WS, if you want to use another protocol, for example MQTT, you must define it.
Thus, the utility methods have the **streamProtocol** property which will be passed to the underlying objects

## Resources
### Systems
Measurement systems (e.g. sensors, sensor networks, actuators, processing components, etc.) that produce observations about features of interest.

<br/>
<DocumentationLoad path="/guide/api/Systems.html"/>

#### Example

```js
const systemsUtility = new Systems({
    endpointUrl: 'api.georobotix.io/ogc/t18/api',
    tls: true,
    streamProtocol: 'mqtt',
    mqttOpts: {
        prefix: '/api',
        endpointUrl: 'api.georobotix.io:443/ogc/t18',
    }
});

const systemCollection = await systemsUtility.searchSystems(systemFilter, 10);
```
### System

System is a JS object containing summary info for the system and methods to access further info.

```js
const systemUtility = new Systems({
    endpointUrl: 'api.georobotix.io/ogc/t18/api',
    tls: true,
    streamProtocol: 'mqtt',
    mqttOpts: {
        prefix: '/api',
        endpointUrl: 'api.georobotix.io:443/ogc/t18',
    }
});

const systemCollection = await systemsUtility.searchSystems(systemFilter, 10);

while (systemCollection.hasNext()) {
    const page = await systemCollection.nextPage();
    for (let i = 0; i < page.length; i++) {
        const system = page[i];
        // do something
    }
}
```

### DataStreams

Datastreams are collections of observations generated by systems and are associated to system outputs.

<br/>
<DocumentationLoad path="/guide/api/DataStreams.html"/>

#### Example

```js
const datastreamsUtility = new DataStreams({
    endpointUrl: 'api.georobotix.io/ogc/t18/api',
    tls: true,
    streamProtocol: 'mqtt',
    mqttOpts: {
        prefix: '/api',
        endpointUrl: 'api.georobotix.io:443/ogc/t18',
    }
});

const datastreamCollection = await datastreamsUtility.searchDataStreams(datastreamFilter, 10);
```

### DataStream

Datastream is a JS object containing summary info for the datastream and methods to access further info.

```js
const datastreamsUtility = new DataStreams({
    endpointUrl: 'api.georobotix.io/ogc/t18/api',
    tls: true,
    streamProtocol: 'mqtt',
    mqttOpts: {
        prefix: '/api',
        endpointUrl: 'api.georobotix.io:443/ogc/t18',
    }
});

const datastreamCollection = await datastreamsUtility.searchDataStreams(datastreamFilter, 10);

while (datastreamCollection.hasNext()) {
    const page = await datastreamCollection.nextPage();
    for (let i = 0; i < page.length; i++) {
        const datastream = page[i];
        // do something
    }
}
```

### FeatureOfInterests

Features of interest are physical or logical entities, often geospatial in nature (but not always) that are the subject
of observations (i.e. whose properties are observed by a system). This collection can include both sampling features and sampled features.

<br/>
<DocumentationLoad path="/guide/api/FeatureOfInterests.html"/>

#### Example

```js
const foiUtility = new FeatureOfInterests({
    endpointUrl: 'api.georobotix.io/ogc/t18/api',
    tls: true,
    streamProtocol: 'mqtt',
    mqttOpts: {
        prefix: '/api',
        endpointUrl: 'api.georobotix.io:443/ogc/t18',
    }
});

const foiCollection = await foiUtility.searchFeaturesOfInterest(foiFilter, 10);
```

### FeatureOfInterest

FeatureOfInterest is a JS object containing summary info for the FeatureOfInterest and methods to access further info.

```js
const foiUtility = new FeatureOfInterests({
    endpointUrl: 'api.georobotix.io/ogc/t18/api',
    tls: true,
    streamProtocol: 'mqtt',
    mqttOpts: {
        prefix: '/api',
        endpointUrl: 'api.georobotix.io:443/ogc/t18',
    }
});

const foiCollection = await foiUtility.searchFeaturesOfInterest(foiFilter, 10);

while (foiCollection.hasNext()) {
    const page = await foiCollection.nextPage();
    for (let i = 0; i < page.length; i++) {
        const foi = page[i];
        // do something
    }
}
```
### Observations

Real-time and historical observations produced by systems

<br/>
<DocumentationLoad path="/guide/api/Observations.html"/>

